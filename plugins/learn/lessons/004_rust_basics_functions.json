{
  "lessonId": "004_rust.basics.functions",
  "lessonNumber": 4,
  "conceptId": "rust.basics.functions",
  "title": "Functions & Returns",
  "markdown": "---\n# Functions & Returns in Rust\n\n## Learning Objectives\n- Understand how to define and call functions in Rust\n- Learn how to specify return types and use the `return` keyword\n- Explore implicit returns and expression-based functions\n- Apply functions to solve a real-world problem (moving average calculation)\n\n## Concept Explanation\nFunctions are fundamental building blocks in Rust. They allow you to organize code into reusable units. A function can take inputs (parameters) and produce an output (return value).\n\nKey points:\n- Use `fn` keyword to declare functions\n- Parameters are specified in parentheses with type annotations\n- Return type is specified after `->` (omitted if function returns `()`)\n- Last expression in a function is automatically returned (implicit return)\n- Use `return` keyword for early returns\n\nCommon pitfalls:\n- Forgetting type annotations for parameters/returns\n- Mismatched return types\n- Confusing expressions vs statements in function bodies\n\n## Code Examples\n\n### Example 1: Basic Function\n```rust\n// Function with explicit return\nfn add(a: i32, b: i32) -> i32 {\n    return a + b;\n}\n\n// Function with implicit return\nfn multiply(a: i32, b: i32) -> i32 {\n    a * b  // No semicolon = expression that gets returned\n}\n\nfn main() {\n    println!(\"2 + 3 = {}\", add(2, 3));\n    println!(\"4 * 5 = {}\", multiply(4, 5));\n}\n```\n\n### Example 2: Applied - Simple Moving Average\n```rust\n// Calculates simple moving average of a window\nfn moving_average(window: &[f64]) -> f64 {\n    let sum: f64 = window.iter().sum();\n    sum / window.len() as f64\n}\n\nfn main() {\n    let prices = [10.0, 12.0, 11.0, 13.0, 14.0];\n    let avg = moving_average(&prices);\n    println!(\"Moving average: {:.2}\", avg);\n}\n```\n\n## Verification Task\n\n**YOUR MISSION:**\nImplement a `calculate_moving_average` function that:\n1. Takes a slice of f64 values and a window size\n2. Returns a Vec<f64> containing moving averages\n3. Handles edge cases (window size > data length, empty input)\n\n**Starter Files:**\n\n**file: src/main.rs**\n```rust\nfn calculate_moving_average(data: &[f64], window_size: usize) -> Vec<f64> {\n    todo!(\"Implement moving average calculation\")\n}\n\nfn main() {\n    let test_data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];\n    let window = 3;\n    let averages = calculate_moving_average(&test_data, window);\n    println!(\"Moving averages: {:?}\", averages);\n}\n```\n\n**Hints:**\n- Use `windows()` method from slices to get sliding windows\n- Remember to handle division by zero for empty windows\n- Consider what to return when window_size > data.len()\n- The first average should be of the first `window_size` elements\n\n**Expected Output:**\n```\nMoving averages: [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n```\n\n**Success Criteria:**\n- [ ] Function compiles without errors\n- [ ] Returns correct moving averages for normal cases\n- [ ] Handles edge cases gracefully (empty input, large window)\n- [ ] Output matches expected format\n\n## Common Mistakes\n1. **Forgetting type annotations**: Rust requires explicit types for function parameters and returns. Always specify `-> Vec<f64>` for return types.\n2. **Mismatched return types**: Ensure your return value matches the declared return type. A `Vec<f64>` is different from `f64`.\n3. **Off-by-one errors**: When calculating windows, be careful with indices. The first window should be elements 0..window_size.\n4. **Division by zero**: Always check window size before division operations.\n\n## Summary\nFunctions in Rust are powerful tools for code organization. Remember:\n- Use `fn` to declare functions with clear parameter types\n- Specify return types with `->` when returning values\n- Leverage implicit returns for cleaner code\n- Handle edge cases to make your functions robust\n- The `windows()` method is your friend for sliding window calculations\n\nMastering functions will give you the foundation to build more complex Rust programs. Keep practicing!",
  "verificationTask": {
    "description": "Implement a `calculate_moving_average` function that:\n1. Takes a slice of f64 values and a window size\n2. Returns a Vec<f64> containing moving averages\n3. Handles edge cases (window size > data length, empty input)",
    "expectedOutput": "Moving averages: [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]",
    "validationCriteria": [
      "Code compiles successfully",
      "Expected output matches"
    ],
    "starterFiles": [
      {
        "path": "src/main.rs",
        "content": "fn calculate_moving_average(data: &[f64], window_size: usize) -> Vec<f64> {\n    todo!(\"Implement moving average calculation\")\n}\n\nfn main() {\n    let test_data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];\n    let window = 3;\n    let averages = calculate_moving_average(&test_data, window);\n    println!(\"Moving averages: {:?}\", averages);\n}"
      }
    ]
  },
  "generatedAt": "2026-01-28T20:11:42.538Z"
}